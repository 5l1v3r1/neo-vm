using Neo.ASML.Node;
using System;
using System.Collections.Generic;
using System.Text;

namespace Neo.ASML
{
    public class DASM
    {


        public static ASMProject Parse(byte[] script)
        {
            //step01.first read
            List<Instruction> codes = new List<Instruction>();
            List<int> calladdrs = new List<int>();
            using (var ms = new System.IO.MemoryStream(script))
            {
                using (var reader = new System.IO.BinaryReader(ms))
                {
                    while (reader.BaseStream.Position < reader.BaseStream.Length)
                    {
                        var code = ReadOneInstruction(reader);
                        codes.Add(code);
                        if (code.opcode == VM.OpCode.CALL)
                        {
                            var calladdr = code.addr + code.offset;
                            if (calladdrs.Contains(calladdr) == false)
                                calladdrs.Add(calladdr);
                        }
                    }
                }
            }

            //step02 split function
            calladdrs.Sort();//little->big

            ASMProject proj = new ASMProject();

            Dictionary<int, FuncRange> mapfuncrange = new Dictionary<int, FuncRange>();


            mapfuncrange.Add(0, new FuncRange()
            { name = "Main", addrbegin = 0, addrend = calladdrs[0] });

            for (var i = 0; i < calladdrs.Count; i++)
            {
                var addrbegin = calladdrs[i];
                var addrend = -1;
                if (i + 1 < calladdrs.Count)
                    addrend = calladdrs[i + 1];

                mapfuncrange[addrbegin] = new FuncRange()
                { name = "Method" + (i + 1).ToString("D03"), addrbegin = addrbegin, addrend = addrend };
            }

            foreach (var info in mapfuncrange)
            {
                var func = ParseFunc(codes, mapfuncrange, info.Value);
                proj.nodes.Add(func);
            }
            return proj;
        }

        public static string GenSource(ASMProject project)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("//this code is generated by Neo.ASML.DASM");
            foreach (var node in project.nodes)
            {
                if (node is ASMComment)
                {
                    var comment = node as ASMComment;
                    sb.AppendLine(comment.text);
                }
                else if (node is ASMFunction)
                {
                    var func = node as ASMFunction;

                    sb.AppendLine(func.Name + "(" + func.commentParams + ")" + func.commentRight);
                    sb.AppendLine("{");
                    var space = "    ";
                    foreach (var sn in func.nodes)
                    {
                        if (sn is ASMComment)
                        {
                            var subcomment = sn as ASMComment;
                            sb.AppendLine(space + subcomment.text);
                        }
                        else if (sn is ASMLabel)
                        {
                            var sublabel = sn as ASMLabel;
                            sb.AppendLine(sublabel.label + ":" + sublabel.commentRight);
                        }
                        else if (sn is ASMInstruction)
                        {
                            var subinst = sn as ASMInstruction;
                            sb.AppendLine(space + subinst.opcode.ToString() + " " + subinst.valuetext + subinst.commentRight);
                        }
                    }
                    sb.AppendLine("}");
                }
            }
            return sb.ToString();
        }
        static ASMFunction ParseFunc(List<Instruction> codes, Dictionary<int, FuncRange> mapfuncrange, FuncRange range)
        {
            ASMFunction func = new ASMFunction();
            func.Name = range.name;
            func.commentRight = "//addr:" + range.addrbegin + "-" + (range.addrend > 0 ? range.addrend.ToString() : "");

            //find jmpaddrs
            List<int> jmpaddrs = new List<int>();
            for (var i = 0; i < codes.Count; i++)
            {
                var code = codes[i];
                if (code.addr >= range.addrbegin && (range.addrend < 0 || code.addr < range.addrend))
                {//in code range

                    //parse all label
                    if (code.opcode == VM.OpCode.JMP || code.opcode == VM.OpCode.JMPIF || code.opcode == VM.OpCode.JMPIFNOT)
                    {
                        var jmpaddr = code.addr + code.offset;
                        if (jmpaddrs.Contains(jmpaddr) == false)
                            jmpaddrs.Add(jmpaddr);
                    }
                }
            }
            jmpaddrs.Sort();
            //gen code
            for (var i = 0; i < codes.Count; i++)
            {
                var code = codes[i];
                if (code.addr >= range.addrbegin && (range.addrend < 0 || code.addr < range.addrend))
                {//in code range
                    if (jmpaddrs.Contains(code.addr))
                    {
                        ASMLabel label = new ASMLabel();
                        label.label = "label" + (jmpaddrs.IndexOf(code.addr) + 1);
                        label.commentRight = "//addr:" + code.addr;
                        func.nodes.Add(label);
                    }
                    ASMInstruction inst = new ASMInstruction();
                    if (code.isPush)
                    {
                        inst.opcode = ASMOpCode.CreatePush();
                        if (code.opcode == VM.OpCode.PUSH0)
                        {
                            inst.valuetext = "0";
                            inst.commentRight = "// or false or empty";
                        }
                        else if (code.opcode == VM.OpCode.PUSHM1)
                        {
                            inst.valuetext = "-1";
                        }
                        else if (code.opcode == VM.OpCode.PUSH1)
                        {
                            inst.valuetext = "1";
                            inst.commentRight = "// or true";
                        }
                        else
                        {
                            inst.valuetext = Data2Str(code.data);
                            inst.commentRight = Data2Comment(code.data);
                        }
                    }
                    else
                    {
                        inst.opcode = ASMOpCode.Create(code.opcode);
                        if (code.opcode == VM.OpCode.CALL)
                        {
                            var calladdr = code.addr + code.offset;
                            var callname = mapfuncrange[calladdr].name;
                            inst.valuetext = callname;
                        }
                        else if (code.opcode == VM.OpCode.JMP || code.opcode == VM.OpCode.JMPIF || code.opcode == VM.OpCode.JMPIFNOT)
                        {
                            var jmpaddr = code.addr + code.offset;
                            var label = "label" + (jmpaddrs.IndexOf(jmpaddr) + 1);
                            inst.valuetext = label;
                        }
                        else if (code.opcode == VM.OpCode.SYSCALL)
                        {
                            inst.valuetext = Data2Str(code.data);
                        }
                        else
                        {
                            //no param
                        }

                    }
                    func.nodes.Add(inst);
                }
            }
            return func;
        }
        class Instruction
        {
            public int addr;
            public Neo.VM.OpCode opcode;
            public bool isPush;
            public byte[] data;
            public Int16 offset;
            public override string ToString()
            {
                return addr.ToString("X04") + ":" + opcode;
            }
        }
        class FuncRange
        {
            public string name;
            public int addrbegin;
            public int addrend;
        }
        static string Data2Str(byte[] data)
        {
            if (data.Length == 1)
            {
                return data[0].ToString();
            }
            else if (data.Length == 2)
            {
                return BitConverter.ToUInt16(data, 0).ToString();
            }
            else
            {
                var outstr = "[";

                for (var i = 0; i < data.Length; i++)
                {
                    if (i > 0)
                        outstr += ",";
                    outstr += data[i].ToString();
                }
                outstr += "]";
                return outstr;
            }
        }
        static string Data2Comment(byte[] data)
        {
            var hexstr = "";
            for (var i = 0; i < data.Length; i++)
            {
                hexstr += data[i].ToString("X02");
            }
            var num = new System.Numerics.BigInteger(data);
            var str = System.Text.Encoding.UTF8.GetString(data);
            foreach (var c in str)
            {
                if (c == '\n' || c == '\r' || c > 0xff)
                {
                    str = null;
                    break;
                }
            }
            var outstr = "//hex[" + hexstr + "] asnum=" + num;
            if (str != null)
                outstr += " asstr=" + str;
            return outstr;

        }
        static Instruction ReadOneInstruction(System.IO.BinaryReader reader)
        {
            Instruction inst = new Instruction();
            inst.addr = (int)reader.BaseStream.Position;
            inst.opcode = (Neo.VM.OpCode)reader.ReadByte();
            //push family
            if (inst.opcode == VM.OpCode.PUSH0)
            {
                inst.isPush = true;
            }
            else if (inst.opcode == VM.OpCode.PUSHM1)
            {
                inst.isPush = true;
            }
            else if (inst.opcode >= VM.OpCode.PUSH1 && inst.opcode <= VM.OpCode.PUSH16)
            {
                var value = (byte)(1 + (inst.opcode - VM.OpCode.PUSH1));
                inst.isPush = true;
                inst.data = new byte[] { value };
            }
            else if (inst.opcode >= VM.OpCode.PUSHBYTES1 && inst.opcode <= VM.OpCode.PUSHBYTES75)
            {
                var valuelength = 1 + (inst.opcode - VM.OpCode.PUSHBYTES1);
                var data = reader.ReadBytes(valuelength);
                inst.isPush = true;
                inst.data = data;
            }
            else if (inst.opcode == VM.OpCode.PUSHDATA1)
            {
                var len = reader.ReadByte();
                var data = reader.ReadBytes(len);
                inst.isPush = true;
                inst.data = data;
            }
            else if (inst.opcode == VM.OpCode.PUSHDATA2)
            {
                var len = reader.ReadUInt16();
                var data = reader.ReadBytes(len);
                inst.isPush = true;
                inst.data = data;
            }
            else if (inst.opcode == VM.OpCode.PUSHDATA4)
            {
                var len = reader.ReadInt32();
                if (len < 0)
                    throw new Exception("too mush PUSHDATA4 bytes");
                var data = reader.ReadBytes((int)len);
                inst.isPush = true;
                inst.data = data;
            }
            else
            {
                inst.isPush = false;
                if (inst.opcode == VM.OpCode.JMP || inst.opcode == VM.OpCode.JMPIF || inst.opcode == VM.OpCode.JMPIFNOT)
                {
                    var offset = reader.ReadInt16();
                    inst.offset = offset;
                }
                else if (inst.opcode == VM.OpCode.CALL)
                {
                    var offset = reader.ReadInt16();
                    inst.offset = offset;
                }
                else if (inst.opcode == VM.OpCode.SYSCALL)
                {
                    var api = reader.ReadBytes(4);
                    inst.data = api;
                }
                else
                {//no param

                }
            }
            return inst;
        }
    }
}
